# Interview List

간단히 개념들을 정리해보며 머리 속에 넣자~

<br>

### 언어(Java, C++ 등..)

---

#### 가비지 컬렉션이란?

> 정리되지 않은 메모리, 유효하지 않은 메모리 주소인 가비지를 정리해주는 프로그램
>
> Heap 메모리를 재활용 하기위해 참조되지 않는 객체들을 해제시켜 가용한 공간을 만드는 작업
>
> 프로그래머가 직접 메모리를 정리하지 않아도 되어 개발 속도가 대폭 향상된다.
>
> 메모리를 언제 되찾을 지 결정하기 위한 오버헤드 발생 문제점 존재

<br>

#### Vector와 ArrayList의 차이는?

> Vector : 동기식. 한 스레드가 벡터 작업 중이면 다른 스레드가 벡터 보유 불가능
>
> ArrayList : 비동기식. 여러 스레드가 arraylist에서 동시 작업이 가능

<br>

#### String과 StringBuffer의 차이는?

> String : 불변. 문자를 수정하려면 지우고 다시 생성해야함 (new) → 문자열 연산이 많으면 기능 떨어짐
>
> StringBuffer : 가변. 한번 만들고 필요할 때 크기를 변경하여 문자를 변경함 (append()와 같이)
>
> StringBuilder : 동기화 지원X. 멀티스레드 환경에 부적합 → 싱글 스레드에서 StringBuffer보다 좋음

<br>

#### Serialization이란?

> 직렬화. 객체의 상태 혹은 데이터 구조를 기록할 수 있는 포맷으로 변환해줌
>
> 나중에 재구성 할 수 있게 자바 객체를 JSON으로 변환해주거나 JSON을 자바 객체로 변환해주는 라이브러리

<br>

#### Java의 메모리 영역은?

> - 메소드 / 스택 / 힙
>
> 메소드 : 바이트 코드, 전역 변수, static 변수
>
> 스택 : 매개 변수, 지역 변수 (사용 끝나면 바로 소멸, 컴파일 시에 메모리 할당)
>
> 힙 : new로 생성된 객체(c에서는 malloc()). 호출이 끝나도 사라지지 않고 프로그램 실행 시 동적 할당

<br>

#### 오버로딩과 오버라이딩 차이는?

> 오버로딩 : 메소드의 이름은 같고, 매개변수를 다르게 함으로써 여러 메소드를 만드는 것
>
> 오버라이딩 : 부모클래스로부터 상속받은 메소드를 재정의하는 것. 자식 객체에서 오버라이딩한 메소드는 호출시 오버라이딩한 메소드가 우선시 되어 호출됨 (동일한 리턴타입, 메소드 이름, 매개변수를 가져야함)

<br>

#### 추상클래스와 인터페이스 차이는?

> 추상클래스 : 클래스 내에 추상 메소드가 하나 이상 포함되거나 abstract로 정의된 경우. extends를 통해 기능을 이용하고 확장하도록 하는 클래스
>
> 인터페이스 : 모든 메소드가 추상 메소드인 경우 (여러 implements가 가능해 다중 상속 구현 가능)  뼈대만 있으며, 구현하는 모든 클래스에 대해 강제적으로 메소드를 구현하도록 만듬

<br>

#### 제네릭이란?

> 클래스에서 사용할 타입을 클래스 외부에서 설정하도록 만드는 것
>
> 제네릭으로 선언한 클래스는, 내가 원하는 타입으로 만들어 사용이 가능함
>
> <>안에는 참조자료형(클래스, 인터페이스, 배열)만 가능함
>
> (기본자료형을 이용하기 위해선 wrapper 클래스를 활용해야 함)

<br>

#### 접근 지정자 4가지

> public : 모든 접근 허용
>
> protected : 상속받은 클래스 or 같은 패키지만 접근 허용
>
> default : 기본 제한자. 자신 클래스 내부 or 같은 패키지만 접근 허용
>
> private : 외부 접근 불가능. 같은 클래스 내에서만 가능

<br>

#### Call by Value vs Call by Reference

> 값에 의한 호출 : 값을 복사해서 새로운 함수로 넘기는 호출 방식. 원본 값 변경X
>
> 참조에 의한 호출 :  주소 값을 인자로 전달하는 호출 방식. 원본 값 변경O

<br>

#### 배열과 연결리스트 차이는?

> 배열은 인덱스를 가짐. 원하는 데이터를 한번에 접근하기 때문에 접근 속도 빠름.
>
> 크기 변경이 불가능하며, 데이터 삽입 및 삭제 시 그 위치의 다음 위치부터 모든 데이터 위치를 변경해야 되는 단점 존재
>
> 연결리스트는 인덱스 대신에 현재 위치의 이전/다음 위치를 기억함.
>
> 크기는 가변적. 인덱스 접근이 아니기 때문에 연결되어 있는 링크를 쭉 따라가야 접근이 가능함. (따라서 배열보다 속도 느림)
>
> 데이터 삽입 및 삭제는 논리적 주소만 바꿔주면 되기 때문에 매우 용이함
>
> - 데이터의 양이 많고 삽입/삭제가 없음. 데이터 검색을 많이 해야할 때 → Array
> - 데이터의 양이 적고 삽입/삭제 빈번함 → LinkedList

<br>

#### Hash란?

> 데이터 삽입 및 삭제 시, 기존 데이터를 밀어내거나 채우지 않고 데이터와 연관된 고유한 숫자를 생성해 인덱스로 사용하는 방법
>
> 검색 속도가 매우 빠르다

<br>

#### Java 컴파일 과정

> 컴파일러가 소스코드를 자바 바이트 코드(.class)로 변환
>
> JVM이 바이트코드를 기계어로 변환하고, 인터프리터 방식으로 애플리케이션 실행

<br>

#### C++ 실행 과정

> 전처리 : #define, #include 지시자 해석
>
> 컴파일 : 고급 언어 소스 프로그램 입력 받고, 어셈블리 파일 만듬
>
> 어셈블 : 어셈블리 파일을 오브젝트 파일로 만듬
>
> 링크 : 오브젝트 파일을 엮어 실행파일을 만들고 라이브러리 함수 연결
>
> 실행

<br>

#### 메모리, 성능을 개선하기 위해 생각나는 방법은?

> static을 사용해 선언한다.
>
> 인스턴스 변수에 접근할 일이 없으면, static 메소드를 선언하여 호출하자
>
> 모든 객체가 서로 공유할 수 있기 때문에 메모리가 절약되고 연속적으로 그 값의 흐름을 이어갈 수 있는 장점이 존재

<br>

<br>

### 운영체제

---

#### 프로세스와 스레드 차이

> 프로세스는 메모리 상에서 실행중인 프로그램을 말하며, 스레드는 이 프로세스 안에서 실행되는 흐름 단위를 말한다.
>
> 프로세스마다 최소 하나의 스레드를 보유하고 있으며, 각각 별도의 주소공간을 독립적으로 할당받는다. (code, data, heap, stack)
>
> 스레드는 이중에 stack만 따로 할당받고 나머지 영역은 스레드끼리 서로 공유한다.
>
> ##### 요약
>
> **프로세스** :  자신만의 고유 공간과 자원을 할당받아 사용
>
> **스레드** : 다른 스레드와 공간과 자원을 공유하면서 사용

<br>

#### 멀티 프로세스로 처리 가능한 걸 굳이 멀티 스레드로 하는 이유는?

> 프로세스를 생성하여 자원을 할당하는 시스템 콜이 감소함으로써 자원의 효율적 관리가 가능함
>
> 프로세스 간의 통신(IPC)보다 스레드 간의 통신 비용이 적어 작업들 간 부담이 감소함
>
> 대신, 멀티 스레드를 사용할 때는 공유 자원으로 인한 문제 해결을 위해 '동기화'에 신경써야 한다.

<br>

#### 교착상태(DeadLock)가 무엇이며, 4가지 조건은?

> 프로세스가 자원을 얻지 못해 다음 처리를 하지 못하는 상태를 말한다.
>
> 시스템적으로 한정된 자원을 여러 곳에서 사용하려고 할 때 발생하는 문제임
>
> 교착상태의 4가지 조건은 아래와 같다.
>
> - 상호배제 : 프로세스들이 필요로 하는 자원에 대해 배타적 통제권을 요구함
> - 점유대기 : 프로세스가 할당된 자원을 가진 상태에서 다른 자원 기다림
> - 비선점 : 프로세스가 어떤 자원의 사용을 끝날 때까지 그 자원을 뺏을 수 없음
> - 순환대기 : 각 프로세스는 순환적으로 다음 프로세스가 요구하는 자원을 갖고 있음
>
> 이 4가지 조건 중 하나라도 만족하지 않으면 교착상태는 발생하지 않음
>
> (순환대기는 점유대기와 비선점을 모두 만족해야만 성립합. 따라서 4가지가 서로 독립적이진 않음)

<br>

#### 교착상태 해결 방법 4가지

> - 예방
> - 회피
> - 무시
> - 발견

<br>

#### 메모리 계층 (상-하층 순)

> |  레지스터  |
> | :--------: |
> |    캐시    |
> |   메모리   |
> | 하드디스크 |

<br>

#### 메모리 할당 알고리즘 First fit, Next fit, Best fit 결과

> - First fit : 메모리의 처음부터 검사해서 크기가 충분한 첫번째 메모리에 할당
> - Next fit : 마지막으로 참조한 메모리 공간에서부터 탐색을 시작해 공간을 찾음
> - Best fit : 모든 메모리 공간을 검사해서 내부 단편화를 최소화하는 공간에 할당

<br>

#### 페이지 교체 알고리즘에 따른 페이지 폴트 방식

> OPT : 최적 교체. 앞으로 가장 오랫동안 사용하지 않을 페이지 교체 (실현 가능성 희박)
>
> FIFO : 메모리가 할당된 순서대로 페이지를 교체
>
> LRU : 최근에 가장 오랫동안 사용하지 않은 페이지를 교체
>
> LFU : 사용 빈도가 가장 적은 페이지를 교체
>
> NUR : 최근에 사용하지 않은 페이지를 교체

<br>

#### 외부 단편화와 내부 단편화란?

> 외부 단편화 : 작업보다 많은 공간이 있더라도 실제로 그 작업을 받아들일 수 없는 경우 (메모리 배치에 따라 발생하는 문제)
>
> 내부 단편화 : 작업에 필요한 공간보다 많은 공간을 할당받음으로써 발생하는 내부의 사용 불가능한 공간

<br>

#### 가상 메모리란?

> 메모리에 로드된, 실행중인 프로세스가 메모리가 아닌 가상의 공간을 참조해 마치 커다란 물리 메모리를 갖는 것처럼 사용할 수 있게 해주는 기법

<br>

#### 페이징과 세그먼테이션이란?

> ##### 페이징 
>
> 페이지 단위의 논리-물리 주소 관리 기법. 
> 논리 주소 공간이 하나의 연속적인 물리 메모리 공간에 들어가야하는 제약을 해결하기 위한 기법
> 논리 주소 공간과 물리 주소 공간을 분리해야함(주소의 동적 재배치 허용), 변환을 위한 MMU 필요
>
> 특징 : 외부 단편화를 없앨 수 있음. 페이지가 클수록 내부 단편화도 커짐
>
> ##### 세그먼테이션
>
> 사용자/프로그래머 관점의 메모리 관리 기법. 페이징 기법은 같은 크기의 페이지를 갖는 것 과는 다르게 논리적 단위(세그먼트)로 나누므로 미리 분할하는 것이 아니고 메모리 사용할 시점에 할당됨

<br>

#### 뮤텍스, 세마포어란?

> 공유된 자원에 여러 프로세스/스레드가 동시 접근하면 문제가 발생할 수 있다. 따라서 공유된 자원 속 하나의 데이터는 한 번에 하나의 프로세스/스레드만 접근할 수 있도록 제한해야 함

뮤텍스 : 공유된 자원에 대한 접근을 한 번에 한 개의 스레드로만 제한(1개 접근 가능한 세마포어)

세마포어 : 공유 자원(critical section)에 접근할 수 있는 스레드의 개수를 제한

<br>

#### Context Switching이란?

> 하나의 프로세스가 CPU를 사용 중인 상태에서 다른 프로세스가 CPU를 사용하도록 하기 위해, 이전의 프로세스 상태를 보관하고 새로운 프로세스의 상태를 적재하는 작업
>
> 한 프로세스의 문맥은 그 프로세스의 PCB에 기록됨

<br>

#### 사용자 수준 스레드 vs 커널 수준 스레드 차이는?

> ##### 사용자 수준 스레드
>
> 장점 : context switching이 없어서 커널 스레드보다 오버헤드가 적음 (스레드 전환 시 커널 스케줄러 호출할 필요가 없기 때문)
>
> 단점 : 프로세스 내의 한 스레드가 커널로 진입하는 순간, 나머지 스레드들도 전부 정지됨 (커널이 스레드의 존재를 알지 못하기 때문에)
>
> ##### 커널 수준 스레드
>
> 장점 : 사용자 수준 스레드보다 효율적임. 커널 스레드를 쓰면 멀티프로세서를 활용할 수 있기 때문이다. 사용자 스레드는 CPU가 아무리 많아도 커널 모드의 스케줄이 되지 않으므로, 각 CPU에 효율적으로 스레드 배당할 수가 없음
>
> 단점 : context switching이 발생함. 이 과정에서 프로세서 모드가 사용자 모드와 커널 모드 사이를 움직이기 때문에 많이 돌아다닐 수록 성능이 떨어지게 된다.



<br>

<br>

### 데이터베이스

------

#### 오라클 시퀀스(Oracle Sequence)

> UNIQUE한 값을 생성해주는 오라클 객체
>
> 시퀀스를 생성하면 PK와 같이 순차적으로 증가하는 컬럼을 자동 생성할수 있다.
>
> ```
> CREATE SEQUENCE 시퀀스이름
> 	START WITH n
> 	INCREMENT BY n ...
> ```

<br>

#### DBMS란?

> 데이터베이스 관리 시스템
>
> 다수의 사용자가 데이터베이스 내의 데이터를 접근할 수 있도록 설계된 시스템

<br>

#### UML이란?

> 프로그램 설계를 표현하기 위해 사용하는 그림으로 된 표기법
>
> 이해하기 힘든 복잡한 시스템을 의사소통하기 위해 만듬

<br>

#### DB에서 View는 무엇인가? 가상 테이블이란?

> 허용된 데이터를 제한적으로 보여주기 위한 것
>
> 하나 이상의 테이블에서 유도된 가상 테이블이다.
>
> - 사용자가 view에 접근했을 때 해당하는 데이터를 원본에서 가져온다.
>
> view에 나타나지 않은 데이터를 간편히 보호할 수 있는 장점 존재 

<br>

#### 정규화란?

> 중복을 최대한 줄여 데이터를 구조화하고, 불필요한 데이터를 제거해 데이터를 논리적으로 저장하는 것
>
> 이상현상이 일어나지 않도록 정규화 시킨다!

<br>

#### 이상현상이란?

> 릴레이션에서 일부 속성들의 종속으로 인해 데이터 중복이 발생하는 것 (insert, update, delete)

<br>

#### 데이터베이스를 설계할 때 가장 중요한 것이 무엇이라고 생각하나요?

> 무결성을 보장해야 합니다.
>
> ##### 무결성 보장 방법은?
>
> 데이터를 조작하는 프로그램 내에서 데이터 생성, 수정, 삭제 시 무결성 조건을 검증한다.
>
> 트리거 이벤트 시 저장 SQL을 실행하고 무결성 조건을 실행한다.
>
> DB제약조건 기능을 선언한다.

<br>

#### 데이터베이스 무결성이란?

> 테이블에 있는 모든 행들이 유일한 식별자를 가질 것을 요구함 (같은 값 X)
>
> 외래키 값은 NULL이거나 참조 테이블의 PK값이어야 함
>
> 한 컬럼에 대해 NULL 허용 여부와 자료형, 규칙으로 타당한 데이터 값 지정

<br>

#### 트리거란?

> 자동으로 실행되도록 정의된 저장 프로시저
>
> (insert, update, delete문에 대한 응답을 자동으로 호출한다.)
>
> ##### 사용하는 이유는?
>
> 업무 규칙 보장, 업무 처리 자동화, 데이터 무결성 강화

<br>

#### 오라클과 MySQL의 차이는?

> 일단 Oracle이 MySQL보다 훨~씬 좋음
>
> 오라클 : 대규모 트랜잭션 로드를 처리하고, 성능 최적화를 위해 여러 서버에 대용량 DB를 분산함
>
> MySQL : 단일 데이터베이스로 제한되어있고, 대용량 데이터베이스로는 부적합. 작은 프로젝트에서 적용시키기 용이하며 이전 상태를 복원하는데 commit과 rollback만 존재

<br>

#### Commit과 Rollback이란?

> Commit : 하나의 논리적 단위(트랜잭션)에 대한 작업이 성공적으로 끝났을 때, 이 트랜잭션이 행한 갱신 연산이 완료된 것을 트랜잭션 관리자에게 알려주는 연산
>
> Rollback : 하나의 트랜잭션 처리가 비정상적으로 종료되어 DB의 일관성을 깨뜨렸을 때, 모든 연산을 취소시키는 연산

<br>

#### JDBC와 ODBC의 차이는?

> - JDBC
>   자바에서 DB에 접근하여 데이터를 조회, 삽입, 수정, 삭제 가능
>   DBMS 종류에 따라 맞는 jdbc를 설치해야함
> - ODBC
>   응용 프로그램에서 DB 접근을 위한 표준 개방형 응용 프로그램 인터페이스
>   MS사에서 만들었으며, Excel/Text 등 여러 종류의 데이터에 접근할 수 있음

<br>

<br>

